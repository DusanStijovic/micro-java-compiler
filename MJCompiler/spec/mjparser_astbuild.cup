package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    
   
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

 	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
      	report_error(message, info);
    }





:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


/*Program terminal */
terminal  PROG;

/*Seperator needed terminals*/
terminal SEMI, COMMA, COLON, DOT;

/*Variable modificator needed terminals*/
terminal  CONST;

/*Bracket types needed terminals*/
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQUARE, RSQUARE;

/*Program control needed terminals*/
terminal IF, ELSE, SWITCH, CASE;

/*Loop needed terminals*/
terminal  CONTINUE, DO, WHILE, BREAK;

/*Class terminals*/
terminal EXTENDS, CLASS, ENUM;

/*Make new variable terminals */
terminal NEW;

/*Operators needed terminals*/
terminal EQUAL_COMPARE, NOT_EQUAL_COMPARE, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR, INC, DEC, TERNAR, PLUS, MINUS, MUL, DIV, MOD, EQUAL;

/*Predefined functions terminals*/
terminal PRINT, READ;

/*Function needed terminals*/
terminal  VOID, RETURN;



terminal BOOLEAN;
terminal Character CHAR;
terminal Integer NUMBER;
terminal String IDENT;


//Program
nonterminal Program Program;
nonterminal ConstVarClassDeclarationList ConstVarClassDeclarationList;

//Group const, var and class
nonterminal ConstVarClassDeclaration ConstVarClassDeclaration;

//Const variable declaration
nonterminal  ConstDeclaration ConstDeclaration;
nonterminal ConstList ConstList;
nonterminal ConstVariableAssginment ConstVariableAssginment;
nonterminal ConstType ConstType;

//Class declaration
nonterminal ExtendClassOption ExtendClassOption;
nonterminal ClassDeclaration ClassDeclaration;
nonterminal OptionalClassMethodsList OptionalClassMethodsList;
nonterminal OptionalClassVarDeclaration OptionalClassVarDeclaration;
nonterminal ClassVariableDeclaration ClassVariableDeclaration;
nonterminal ClassVarList ClassVarList;
nonterminal ClassVariable ClassVariable;
nonterminal ClassVariableDeclarationList ClassVariableDeclarationList;

//Variable declaration
nonterminal VariableDeclaration VariableDeclaration;
nonterminal VarList VarList;
nonterminal Variable Variable;
nonterminal VariableDeclarationList VariableDeclarationList;


//GlobalVariable
nonterminal GlobalVariableDeclaration GlobalVariableDeclaration;
nonterminal GlobalVarList GlobalVarList;
nonterminal GlobalVariable GlobalVariable;


//Method declaration
nonterminal MethodDeclarationList MethodDeclarationList;
nonterminal ReturnType ReturnType;
nonterminal MethodDeclaration MethodDeclaration;
nonterminal OptionalMethodsLocalVariablesDeclaration OptionalMethodsLocalVariablesDeclaration;


//Method formal parameter declaration
nonterminal OptionalMethodFormalParams OptionalMethodFormalParams;
nonterminal FormalParamDeclaration FormalParamDeclaration;
nonterminal FormalParamDeclarationList FormalParamDeclarationList;
nonterminal OptionalSquareMethodFormalParam OptionalSquareMethodFormalParam;

//Method actual parameter declaration
nonterminal OptionalMethodActualParameters OptionalMethodActualParameters;
nonterminal ActualParamDeclarationList ActualParamDeclarationList;


//Designator
nonterminal Designator Designator;
nonterminal OptionalSpecifeIdentPartList OptionalSpecifeIdentPartList;
nonterminal DesignatorPart DesignatorPart;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal SpecifeIdentPart SpecifeIdentPart;
nonterminal SpecifeIdentPartList SpecifeIdentPartList;
nonterminal AssignmentStatement AssignmentStatement;


//Operators
nonterminal AddOperator AddOperator;
nonterminal  MultiplyOperator MultiplyOperator;
nonterminal RelationalOperator RelationalOperator;
nonterminal AssignmentOperator AssignmentOperator;


//Expression
nonterminal Expr Expr;
nonterminal Expr1 Expr1 ;
nonterminal OptionalMinusVar OptionalMinusVar;

//Term
nonterminal TermList TermList;
nonterminal Term Term;

//Factor
nonterminal FactorList FactorList;
nonterminal Factor Factor;
nonterminal OptionalSquareNewOp OptionalSquareNewOp;

//Condition
nonterminal Condition Condition;
nonterminal ConditionFact ConditionFact;
nonterminal ConditionTerm ConditionTerm;

//Statement
nonterminal Statement Statement;
nonterminal StatementList StatementList;
nonterminal Matched Matched;
nonterminal Unmatched Unmatched;


//Variables Type
nonterminal  Type Type;

//Case statment
nonterminal CaseStatementList CaseStatementList;
nonterminal CaseStatement CaseStatement;

//print oprional variable
nonterminal OptionalPrintParam OptionalPrintParam;




/*PROGRAM*/
Program ::= (Program) PROG IDENT:programName ConstVarClassDeclarationList:C1 LBRACE MethodDeclarationList:M2 RBRACE {: RESULT=new Program(programName, C1, M2); RESULT.setLine(programNameleft); :}
		;


/*Const Var Class Declaration List */
ConstVarClassDeclarationList ::= (ConstVarClassDeclList) ConstVarClassDeclarationList:C1  ConstVarClassDeclaration:C2 {: RESULT=new ConstVarClassDeclList(C1, C2); RESULT.setLine(C1left); :}
							| 
								(NoConstVarClassDeclList) {: RESULT=new NoConstVarClassDeclList(); :} /*epsilon*/
							;

ConstVarClassDeclaration ::= (GlobalConstDecl) ConstDeclaration:C1 {: RESULT=new GlobalConstDecl(C1); RESULT.setLine(C1left); :}
						|
							(GlobalVariableDecl) GlobalVariableDeclaration:G1 {: RESULT=new GlobalVariableDecl(G1); RESULT.setLine(G1left); :}
						|
							(GlobalCLassDecl) ClassDeclaration:C1 {: RESULT=new GlobalCLassDecl(C1); RESULT.setLine(C1left); :}
						;


/*Const declaration */

ConstDeclaration ::=  (ConstVarDecl) CONST Type:constType ConstList:C1 SEMI {: RESULT=new ConstVarDecl(constType, C1); RESULT.setLine(constTypeleft); :}
				;

ConstList ::= (ConstDeclList)  ConstList:C1 COMMA ConstVariableAssginment:C2 {: RESULT=new ConstDeclList(C1, C2); RESULT.setLine(C1left); :}
		|
		 	  (OneConstDecl) ConstVariableAssginment:C1 {: RESULT=new OneConstDecl(C1); RESULT.setLine(C1left); :}
		;

ConstVariableAssginment ::= (ConstVarAssign) IDENT:VarName EQUAL ConstType:C1 {: RESULT=new ConstVarAssign(VarName, C1); RESULT.setLine(VarNameleft); :}
				;

ConstType ::= (ConstVarType) NUMBER:assignedValue {: RESULT=new ConstVarType(assignedValue); RESULT.setLine(assignedValueleft); :}
		|
			 (CharType) CHAR:assignedValue {: RESULT=new CharType(assignedValue); RESULT.setLine(assignedValueleft); :}
		|
			 (BooleanType) BOOLEAN:assignedValue {: RESULT=new BooleanType(); :}
		;


/*Class declaration */
ClassDeclaration ::= (ClassTypeDecl) CLASS IDENT:className ExtendClassOption:E1 LBRACE OptionalClassVarDeclaration:O2 OptionalClassMethodsList:O3 RBRACE {: RESULT=new ClassTypeDecl(className, E1, O2, O3); RESULT.setLine(classNameleft); :}
				;

OptionalClassVarDeclaration ::= (ClassVariableDecl) ClassVariableDeclarationList:C1 {: RESULT=new ClassVariableDecl(C1); RESULT.setLine(C1left); :}
							|
								(NoClassVariableDecl) {: RESULT=new NoClassVariableDecl(); :} /*epsilon*/
					;


ExtendClassOption ::= (ExtensionClass) EXTENDS Type:classExtendedType {: RESULT=new ExtensionClass(classExtendedType); RESULT.setLine(classExtendedTypeleft); :}
				| 
					(NoExtensionClass) {: RESULT=new NoExtensionClass(); :} /*epsilon*/
				| 
					(ErrorExtenstionClass) error:l
					{: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null);  :} {: RESULT=new ErrorExtenstionClass(); :}
				;
		
OptionalClassMethodsList ::= (ClassMethods) LBRACE MethodDeclarationList:M1 RBRACE {: RESULT=new ClassMethods(M1); RESULT.setLine(M1left); :}
						|
							(NoClassMethods) {: RESULT=new NoClassMethods(); :}/*epsilon*/				
						;		

//ClassVariable

ClassVariableDeclaration ::= (ClassVariableDeclList) Type:classVarType ClassVarList:C1 SEMI {: RESULT=new ClassVariableDeclList(classVarType, C1); RESULT.setLine(classVarTypeleft); :}
			|
			(ClassVariableErrorBrace) error:l
			{: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null);  :} {: RESULT=new ClassVariableErrorBrace(); :}
			|
			(ClassVariableErrorDecl) error:l SEMI
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new ClassVariableErrorDecl(); :}			
			;
		

ClassVarList ::=  (ClassVariableList) ClassVarList:C1 COMMA ClassVariable:C2 {: RESULT=new ClassVariableList(C1, C2); RESULT.setLine(C1left); :}
		| 
		    	  (ClassOneVariable) ClassVariable:C1 {: RESULT=new ClassOneVariable(C1); RESULT.setLine(C1left); :}
		;	
			
ClassVariable ::= (ClassArrrayVariable) IDENT:classVarName LSQUARE RSQUARE {: RESULT=new ClassArrrayVariable(classVarName); RESULT.setLine(classVarNameleft); :}
				|
				   (ClassNoArrayVariable) IDENT:clasVarName {: RESULT=new ClassNoArrayVariable(clasVarName); RESULT.setLine(clasVarNameleft); :}
				;

/*Multiple class variable declarations */
ClassVariableDeclarationList ::= (ClassVarDeclList) ClassVariableDeclarationList:C1 ClassVariableDeclaration:C2 {: RESULT=new ClassVarDeclList(C1, C2); RESULT.setLine(C1left); :}
			| 
					(ClassOneVarDecl) ClassVariableDeclaration:C1 {: RESULT=new ClassOneVarDecl(C1); RESULT.setLine(C1left); :}
			;


/*Variable*/
VariableDeclaration ::= (VariableDecl) Type:varType VarList:V1 SEMI {: RESULT=new VariableDecl(varType, V1); RESULT.setLine(varTypeleft); :}
	;
		

VarList ::= (VariableList) VarList:V1 COMMA Variable:V2 {: RESULT=new VariableList(V1, V2); RESULT.setLine(V1left); :}
			| 
			(OneVariable) Variable:V1 {: RESULT=new OneVariable(V1); RESULT.setLine(V1left); :}
			;
			
Variable ::= (ArrrayVariable) IDENT:varName LSQUARE RSQUARE {: RESULT=new ArrrayVariable(varName); RESULT.setLine(varNameleft); :}
		|
			(NoArrayVariable) IDENT:varName {: RESULT=new NoArrayVariable(varName); RESULT.setLine(varNameleft); :}
		;

/*Multiple variable declarations */
VariableDeclarationList ::= (VarDeclList) VariableDeclarationList:V1 VariableDeclaration:V2 {: RESULT=new VarDeclList(V1, V2); RESULT.setLine(V1left); :}
			| 
					(OneVarDecl) VariableDeclaration:V1 {: RESULT=new OneVarDecl(V1); RESULT.setLine(V1left); :}
			;


//GlobalVariable

GlobalVariableDeclaration ::= (GlobalVariableDeclList) Type:globalVarType GlobalVarList:G1 SEMI {: RESULT=new GlobalVariableDeclList(globalVarType, G1); RESULT.setLine(globalVarTypeleft); :}
			;
		

GlobalVarList ::= (GlobalVariableList) GlobalVarList:G1 COMMA GlobalVariable:G2 {: RESULT=new GlobalVariableList(G1, G2); RESULT.setLine(G1left); :}
			| 
				  (GlobalOneVariable) GlobalVariable:G1 {: RESULT=new GlobalOneVariable(G1); RESULT.setLine(G1left); :}
			;
			
GlobalVariable ::= (GlobalArrrayVariable) IDENT:globalVarName LSQUARE RSQUARE {: RESULT=new GlobalArrrayVariable(globalVarName); RESULT.setLine(globalVarNameleft); :}
		|
			(GlobalNoArrayVariable) IDENT:globalVarName {: RESULT=new GlobalNoArrayVariable(globalVarName); RESULT.setLine(globalVarNameleft); :}
		|
			(GlobalVariableError) error:l
		{: parser.report_error("Izvrsen oporavak do , ili ; u liniji " + lleft, null);  :} {: RESULT=new GlobalVariableError(); :}
		;



/*Var type nonterminal */
Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :}
		;


/*Methods*/
MethodDeclarationList ::= (MethodDeclList) MethodDeclarationList:M1 MethodDeclaration:M2 {: RESULT=new MethodDeclList(M1, M2); RESULT.setLine(M1left); :}
				|
						  (NoMethodDecList) {: RESULT=new NoMethodDecList(); :} /*epsilon*/				
				;
				
MethodDeclaration ::= (MethodDecl) ReturnType:R1 IDENT:methodName LPAREN OptionalMethodFormalParams:O2 RPAREN OptionalMethodsLocalVariablesDeclaration:O3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(R1, methodName, O2, O3, S4); RESULT.setLine(R1left); :}
					;

OptionalMethodsLocalVariablesDeclaration ::= (MethodLocalVariableDecl) VariableDeclarationList:V1 {: RESULT=new MethodLocalVariableDecl(V1); RESULT.setLine(V1left); :}
										|    (NoMethodLocalVariableDecl) {: RESULT=new NoMethodLocalVariableDecl(); :} /*epsilon*/
										;

ReturnType ::= (FunctionReturnType) Type:returnType {: RESULT=new FunctionReturnType(returnType); RESULT.setLine(returnTypeleft); :}
			|  
				(NoReturnType) VOID {: RESULT=new NoReturnType(); :}
			;
			



/*Method Formal Parameters*/
OptionalMethodFormalParams ::= (MethodFormalParams) FormalParamDeclarationList:F1 {: RESULT=new MethodFormalParams(F1); RESULT.setLine(F1left); :}
		 				 |
		 					(NoMethodFormalParams) {: RESULT=new NoMethodFormalParams(); :} /* epsilon */
		 				 ;
		  
FormalParamDeclarationList ::= (FormalParamDeclList) FormalParamDeclarationList:F1 COMMA FormalParamDeclaration:F2 {: RESULT=new FormalParamDeclList(F1, F2); RESULT.setLine(F1left); :}
				|
							(OneFormalParamDecl) FormalParamDeclaration:F1 {: RESULT=new OneFormalParamDecl(F1); RESULT.setLine(F1left); :}
				;
				
FormalParamDeclaration ::= (FormalParamDecl) Type:formalParamType IDENT:formalParamName OptionalSquareMethodFormalParam:O1 {: RESULT=new FormalParamDecl(formalParamType, formalParamName, O1); RESULT.setLine(formalParamTypeleft); :}
						| 
							(ErrorFormalParamDecl) error:l
							{: parser.report_error("Izvrsen oporavak do ; ili , u liniji " + lleft, null);  :} {: RESULT=new ErrorFormalParamDecl(); :}
					;



OptionalSquareMethodFormalParam ::=  (ArrayFormalParam) LSQUARE RSQUARE {: RESULT=new ArrayFormalParam(); :}
				|
									(NoArrayFormalParam) {: RESULT=new NoArrayFormalParam(); :}/*epsilon*/
				;				


		
/*Method Actual parameters*/ 
OptionalMethodActualParameters ::= (MethodActualParams) ActualParamDeclarationList:A1 {: RESULT=new MethodActualParams(A1); RESULT.setLine(A1left); :}
								| (NoMethodActualParams) {: RESULT=new NoMethodActualParams(); :}/*epsilon*/
								;

ActualParamDeclarationList ::=  (ActualParamDeclList) ActualParamDeclarationList:A1 COMMA Expr:E2 {: RESULT=new ActualParamDeclList(A1, E2); RESULT.setLine(A1left); :}
							|
								(OneActualParamDecl) Expr:E1 {: RESULT=new OneActualParamDecl(E1); RESULT.setLine(E1left); :}
							;
				



/*DESIGNATOR*/

Designator ::= (Designator) IDENT:variableName OptionalSpecifeIdentPartList:O1 {: RESULT=new Designator(variableName, O1); RESULT.setLine(variableNameleft); :}
			;

OptionalSpecifeIdentPartList ::= (IdentParts) SpecifeIdentPartList:S1 {: RESULT=new IdentParts(S1); RESULT.setLine(S1left); :}
						|
								(NoIdentParts) {: RESULT=new NoIdentParts(); :} /*epsilon*/
						;
					
SpecifeIdentPartList ::= (IdentPartList) SpecifeIdentPartList:S1 SpecifeIdentPart:S2 {: RESULT=new IdentPartList(S1, S2); RESULT.setLine(S1left); :}
					|
						(OneIdentPart) SpecifeIdentPart:S1 {: RESULT=new OneIdentPart(S1); RESULT.setLine(S1left); :}
					;


SpecifeIdentPart ::= (ClassMemberPart) DOT IDENT:classfieldName {: RESULT=new ClassMemberPart(classfieldName); RESULT.setLine(classfieldNameleft); :}
					|
					 (ArrayMemberPart) LSQUARE Expr:E1 RSQUARE {: RESULT=new ArrayMemberPart(E1); RESULT.setLine(E1left); :}	
					;
				
DesignatorPart ::=  (AssignmentStmt) AssignmentStatement:A1 {: RESULT=new AssignmentStmt(A1); RESULT.setLine(A1left); :}
				|	
				    (MetodCall) LPAREN OptionalMethodActualParameters:O1 RPAREN {: RESULT=new MetodCall(O1); RESULT.setLine(O1left); :}
				|	
				    (IncrementDesignator) INC {: RESULT=new IncrementDesignator(); :}
				|	
				    (DecrementDesignator) DEC {: RESULT=new DecrementDesignator(); :}
				;

				
DesignatorStatement ::= (DesignatorStmt) Designator:D1 DesignatorPart:D2 {: RESULT=new DesignatorStmt(D1, D2); RESULT.setLine(D1left); :}
					;

AssignmentStatement ::= (AssignmentExpr)  AssignmentOperator:A1 Expr:E2 {: RESULT=new AssignmentExpr(A1, E2); RESULT.setLine(A1left); :}
					|
					(AssignmentError) error:l
					{: parser.report_error("Izvrsen oporavak do ; ili , u liniji " + lleft, null);  :} {: RESULT=new AssignmentError(); :}
					;
			

/*OPERATORS*/

AddOperator ::= (PlusOp) PLUS {: RESULT=new PlusOp(); :}
			|
				(MinusOp) MINUS {: RESULT=new MinusOp(); :}
			;

MultiplyOperator ::= (MultiplyOp) MUL {: RESULT=new MultiplyOp(); :}
				|
				(DivideOp) DIV {: RESULT=new DivideOp(); :}
				|
				(ModuloOp) MOD {: RESULT=new ModuloOp(); :}
				;

RelationalOperator ::=  (EqualOp) EQUAL_COMPARE {: RESULT=new EqualOp(); :}
					| 
						(NotEqualOp) NOT_EQUAL_COMPARE {: RESULT=new NotEqualOp(); :}
					|
						(GreaterOp) GREATER {: RESULT=new GreaterOp(); :}
					|
						(GreaterEqualOp) GREATER_EQUAL {: RESULT=new GreaterEqualOp(); :}
					|
						(LessOp) LESS {: RESULT=new LessOp(); :}
					|
						(LessEqualOp) LESS_EQUAL {: RESULT=new LessEqualOp(); :}
					;

AssignmentOperator ::= (AssignOp) EQUAL {: RESULT=new AssignOp(); :}
				;



/*Expression*/
Expr ::=    (TernarExpr) Expr1:E1 TERNAR Expr1:E2 COLON Expr1:E3 {: RESULT=new TernarExpr(E1, E2, E3); RESULT.setLine(E1left); :}
		| 
			(NoTernarExpression) Expr1:E1 {: RESULT=new NoTernarExpression(E1); RESULT.setLine(E1left); :}
		;
			
Expr1 ::= (BasicExpression) OptionalMinusVar:O1 TermList:T2 {: RESULT=new BasicExpression(O1, T2); RESULT.setLine(O1left); :}
	 	;
	 
OptionalMinusVar ::= (TermHaveMinus) MINUS {: RESULT=new TermHaveMinus(); :}
				 |
				  (TermDoNotHaveMinus) {: RESULT=new TermDoNotHaveMinus(); :} /*epsilon*/
	 			;
	 
TermList ::= (MultipleTerms) TermList:T1 AddOperator:A2 Term:T3 {: RESULT=new MultipleTerms(T1, A2, T3); RESULT.setLine(T1left); :}
		|
		 (OneTerm) Term:T1 {: RESULT=new OneTerm(T1); RESULT.setLine(T1left); :}
		;



/*TERM*/
Term ::= (TermDescription) FactorList:F1 {: RESULT=new TermDescription(F1); RESULT.setLine(F1left); :};

FactorList ::= (MultipleFactors) FactorList:F1 MultiplyOperator:M2 Factor:F3 {: RESULT=new MultipleFactors(F1, M2, F3); RESULT.setLine(F1left); :}
		|
			 (OneFactor) Factor:F1 {: RESULT=new OneFactor(F1); RESULT.setLine(F1left); :}
		;



/*FACTOR*/
Factor ::= (NumConst) NUMBER:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
		| 
			(CharConst) CHAR:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
		| 
			(BoolConst) BOOLEAN {: RESULT=new BoolConst(); :}
		| 
			(NewOperator) NEW Type:T1  OptionalSquareNewOp:O2 {: RESULT=new NewOperator(T1, O2); RESULT.setLine(T1left); :}
		| 
			(Var) Designator:d {: RESULT=new Var(d); RESULT.setLine(dleft); :}
		| 
			(FuncCall) Designator:D1 LPAREN OptionalMethodActualParameters:O2 RPAREN {: RESULT=new FuncCall(D1, O2); RESULT.setLine(D1left); :}
		| 
			(ExprFactor) LPAREN Expr:E1 RPAREN {: RESULT=new ExprFactor(E1); RESULT.setLine(E1left); :}
		;
		
OptionalSquareNewOp ::= (NewArrayVariable)  LSQUARE Expr:E1 RSQUARE {: RESULT=new NewArrayVariable(E1); RESULT.setLine(E1left); :}
					| 
					 	(NewNonArrayVariable) {: RESULT=new NewNonArrayVariable(); :} /*epsilon*/
 					;


					 
/*CONDITION*/


Condition ::= (ConditionListOr) Condition:C1 OR ConditionTerm:C2 {: RESULT=new ConditionListOr(C1, C2); RESULT.setLine(C1left); :}
			|
			  (OneConditionOr) ConditionTerm:C1 {: RESULT=new OneConditionOr(C1); RESULT.setLine(C1left); :}
			|
			  (ErrorCondition) {: RESULT=new ErrorCondition(); :}/*epsilon*/
			;


ConditionTerm ::=  	(ConditionListAnd) ConditionTerm:C1 AND ConditionFact:C2 {: RESULT=new ConditionListAnd(C1, C2); RESULT.setLine(C1left); :}
				|
					(OneConditionAnd) ConditionFact:C1 {: RESULT=new OneConditionAnd(C1); RESULT.setLine(C1left); :}
				;

ConditionFact ::= (TwoVariablesCondition)  Expr:E1 RelationalOperator:R2 Expr:E3 {: RESULT=new TwoVariablesCondition(E1, R2, E3); RESULT.setLine(E1left); :}
				| 
				   (OneVariableCondition) Expr:E1 {: RESULT=new OneVariableCondition(E1); RESULT.setLine(E1left); :}

				;
/*STATEMENT*/



Statement ::= (MatchedStmt) Matched:M1 {: RESULT=new MatchedStmt(M1); RESULT.setLine(M1left); :}
		   |
		   	  (UnmatchedStmt) Unmatched:U1 {: RESULT=new UnmatchedStmt(U1); RESULT.setLine(U1left); :}
		   ; 
		   
StatementList ::= (StmtList) StatementList:S1 Statement:S2 {: RESULT=new StmtList(S1, S2); RESULT.setLine(S1left); :}
		   |
		   		  (NoStmt) {: RESULT=new NoStmt(); :} /*epsilon*/
		   ;

Unmatched ::=	(UnmatchedIf) IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new UnmatchedIf(C1, S2); RESULT.setLine(C1left); :}
		 	|
		 		(UnmatchedIfElse) IF  LPAREN Condition:C1 RPAREN Matched:M2 ELSE Unmatched:U3 {: RESULT=new UnmatchedIfElse(C1, M2, U3); RESULT.setLine(C1left); :}
		 	;


Matched ::= (MatchedDesignator) DesignatorStatement:D1 SEMI {: RESULT=new MatchedDesignator(D1); RESULT.setLine(D1left); :}
		   |
		   (DoStmt) DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new DoStmt(S1, C2); RESULT.setLine(S1left); :}
		   |
		   (PrintStmt) PRINT LPAREN Expr:E1 OptionalPrintParam:O2 RPAREN SEMI {: RESULT=new PrintStmt(E1, O2); RESULT.setLine(E1left); :}
		   |
		   (ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :}
		   |
		   (ContinueStmt) CONTINUE SEMI {: RESULT=new ContinueStmt(); :}
		   |
		   (BreakStmt) BREAK SEMI {: RESULT=new BreakStmt(); :}
		   |
		   (ReturnExpr) RETURN Expr:E1 SEMI {: RESULT=new ReturnExpr(E1); RESULT.setLine(E1left); :}
		   |
		   (ReturnNoExpr) RETURN SEMI {: RESULT=new ReturnNoExpr(); :}
		   |
		   (MatchedStatement) IF LPAREN Condition:C1 RPAREN Matched:M2 ELSE Matched:M3 {: RESULT=new MatchedStatement(C1, M2, M3); RESULT.setLine(C1left); :}
		   |
		   (MultipleStatement) LBRACE StatementList:S1 RBRACE {: RESULT=new MultipleStatement(S1); RESULT.setLine(S1left); :}
		   |
		   (SwithStmt) SWITCH LPAREN Expr:E1 RPAREN LBRACE CaseStatementList:C2 RBRACE {: RESULT=new SwithStmt(E1, C2); RESULT.setLine(E1left); :}
		   ;

/*Print statement optional parameter */
OptionalPrintParam ::=  (AditionalParamPrint) COMMA NUMBER:N1 {: RESULT=new AditionalParamPrint(N1); RESULT.setLine(N1left); :}
					| 
						(NoAditionalParamPrint) {: RESULT=new NoAditionalParamPrint(); :} /*epsilon*/
					; 


/*CASE STATEMENT*/
CaseStatementList ::= (CaseStmtList) CaseStatementList:C1 CaseStatement:C2 {: RESULT=new CaseStmtList(C1, C2); RESULT.setLine(C1left); :}
				| (NoCaseStmt) {: RESULT=new NoCaseStmt(); :} /*epsilon*/
				;

CaseStatement ::= (CaseStmt) CASE NUMBER:N1 COLON StatementList:S2 {: RESULT=new CaseStmt(N1, S2); RESULT.setLine(N1left); :}
				;	





					