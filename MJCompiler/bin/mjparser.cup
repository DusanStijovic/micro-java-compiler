package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    
   
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

 	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
      	report_error(message, info);
    }





:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


/*Program terminal */
terminal  PROG;

/*Seperator needed terminals*/
terminal SEMI, COMMA, COLON, DOT;

/*Variable modificator needed terminals*/
terminal  CONST;

/*Bracket types needed terminals*/
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQUARE, RSQUARE;

/*Program control needed terminals*/
terminal IF, ELSE, SWITCH, CASE;

/*Loop needed terminals*/
terminal  CONTINUE, DO, WHILE, BREAK;

/*Class terminals*/
terminal EXTENDS, CLASS, ENUM;

/*Make new variable terminals */
terminal NEW;

/*Operators needed terminals*/
terminal EQUAL_COMPARE, NOT_EQUAL_COMPARE, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR, INC, DEC, TERNAR, PLUS, MINUS, MUL, DIV, MOD, EQUAL;

/*Predefined functions terminals*/
terminal PRINT, READ;

/*Function needed terminals*/
terminal  VOID, RETURN;



terminal BOOLEAN;
terminal Character CHAR;
terminal Integer NUMBER;
terminal String IDENT;


//Program
nonterminal Program, ConstVarClassDeclarationList;

//Group const, var and class
nonterminal ConstVarClassDeclaration;

//Const variable declaration
nonterminal  ConstDeclaration, ConstList, ConstVariableAssginment, ConstType;

//Class declaration
nonterminal ExtendClassOption, ClassDeclaration, OptionalClassMethodsList, OptionalClassVarDeclaration;
nonterminal ClassVariableDeclaration, ClassVarList, ClassVariable, ClassVariableDeclarationList;

//Variable declaration
nonterminal VariableDeclaration, VarList, Variable, VariableDeclarationList;


//GlobalVariable
nonterminal GlobalVariableDeclaration, GlobalVarList, GlobalVariable;


//Method declaration
nonterminal MethodDeclarationList, ReturnType, MethodDeclaration, OptionalMethodsLocalVariablesDeclaration;


//Method formal parameter declaration
nonterminal OptionalMethodFormalParams, FormalParamDeclaration, FormalParamDeclarationList, OptionalSquareMethodFormalParam;

//Method actual parameter declaration
nonterminal OptionalMethodActualParameters, ActualParamDeclarationList;


//Designator
nonterminal Designator, OptionalSpecifeIdentPartList, DesignatorPart, DesignatorStatement;
nonterminal SpecifeIdentPart, SpecifeIdentPartList, AssignmentStatement;


//Operators
nonterminal AddOperator,  MultiplyOperator, RelationalOperator, AssignmentOperator;


//Expression
nonterminal Expr, Expr1 , OptionalMinusVar;

//Term
nonterminal TermList, Term;

//Factor
nonterminal FactorList, Factor, OptionalSquareNewOp;

//Condition
nonterminal Condition, ConditionFact, ConditionTerm;

//Statement
nonterminal Statement, StatementList, Matched, Unmatched;


//Variables Type
nonterminal  Type;

//Case statment
nonterminal CaseStatementList, CaseStatement;

//print oprional variable
nonterminal OptionalPrintParam;




/*PROGRAM*/
Program ::= (Program) PROG IDENT:programName ConstVarClassDeclarationList LBRACE MethodDeclarationList RBRACE
		;


/*Const Var Class Declaration List */
ConstVarClassDeclarationList ::= (ConstVarClassDeclList) ConstVarClassDeclarationList  ConstVarClassDeclaration
							| 
								(NoConstVarClassDeclList) /*epsilon*/
							;

ConstVarClassDeclaration ::= (GlobalConstDecl) ConstDeclaration
						|
							(GlobalVariableDecl) GlobalVariableDeclaration
						|
							(GlobalCLassDecl) ClassDeclaration
						;


/*Const declaration */

ConstDeclaration ::=  (ConstVarDecl) CONST Type:constType ConstList SEMI
				;

ConstList ::= (ConstDeclList)  ConstList COMMA ConstVariableAssginment
		|
		 	  (OneConstDecl) ConstVariableAssginment
		;

ConstVariableAssginment ::= (ConstVarAssign) IDENT:VarName EQUAL ConstType
				;

ConstType ::= (ConstVarType) NUMBER:assignedValue
		|
			 (CharType) CHAR:assignedValue
		|
			 (BooleanType) BOOLEAN:assignedValue
		;


/*Class declaration */
ClassDeclaration ::= (ClassTypeDecl) CLASS IDENT:className ExtendClassOption LBRACE OptionalClassVarDeclaration OptionalClassMethodsList RBRACE
				;

OptionalClassVarDeclaration ::= (ClassVariableDecl) ClassVariableDeclarationList
							|
								(NoClassVariableDecl) /*epsilon*/
					;


ExtendClassOption ::= (ExtensionClass) EXTENDS Type:classExtendedType
				| 
					(NoExtensionClass) /*epsilon*/
				| 
					(ErrorExtenstionClass) error:l
					{: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null);  :}
				;
		
OptionalClassMethodsList ::= (ClassMethods) LBRACE MethodDeclarationList RBRACE
						|
							(NoClassMethods)/*epsilon*/				
						;		

//ClassVariable

ClassVariableDeclaration ::= (ClassVariableDeclList) Type:classVarType ClassVarList SEMI
			|
			(ClassVariableErrorBrace) error:l
			{: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null);  :}
			|
			(ClassVariableErrorDecl) error:l SEMI
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :}			
			;
		

ClassVarList ::=  (ClassVariableList) ClassVarList COMMA ClassVariable
		| 
		    	  (ClassOneVariable) ClassVariable
		;	
			
ClassVariable ::= (ClassArrrayVariable) IDENT:classVarName LSQUARE RSQUARE
				|
				   (ClassNoArrayVariable) IDENT:clasVarName
				;

/*Multiple class variable declarations */
ClassVariableDeclarationList ::= (ClassVarDeclList) ClassVariableDeclarationList ClassVariableDeclaration
			| 
					(ClassOneVarDecl) ClassVariableDeclaration
			;


/*Variable*/
VariableDeclaration ::= (VariableDecl) Type:varType VarList SEMI
	;
		

VarList ::= (VariableList) VarList COMMA Variable
			| 
			(OneVariable) Variable
			;
			
Variable ::= (ArrrayVariable) IDENT:varName LSQUARE RSQUARE
		|
			(NoArrayVariable) IDENT:varName
		;

/*Multiple variable declarations */
VariableDeclarationList ::= (VarDeclList) VariableDeclarationList VariableDeclaration
			| 
					(OneVarDecl) VariableDeclaration
			;


//GlobalVariable

GlobalVariableDeclaration ::= (GlobalVariableDeclList) Type:globalVarType GlobalVarList SEMI
			;
		

GlobalVarList ::= (GlobalVariableList) GlobalVarList COMMA GlobalVariable
			| 
				  (GlobalOneVariable) GlobalVariable
			;
			
GlobalVariable ::= (GlobalArrrayVariable) IDENT:globalVarName LSQUARE RSQUARE
		|
			(GlobalNoArrayVariable) IDENT:globalVarName
		|
			(GlobalVariableError) error:l
		{: parser.report_error("Izvrsen oporavak do , ili ; u liniji " + lleft, null);  :}
		;



/*Var type nonterminal */
Type ::= (Type) IDENT:typeName
		;


/*Methods*/
MethodDeclarationList ::= (MethodDeclList) MethodDeclarationList MethodDeclaration
				|
						  (NoMethodDecList) /*epsilon*/				
				;
				
MethodDeclaration ::= (MethodDecl) ReturnType IDENT:methodName LPAREN OptionalMethodFormalParams RPAREN OptionalMethodsLocalVariablesDeclaration LBRACE StatementList RBRACE
					;

OptionalMethodsLocalVariablesDeclaration ::= (MethodLocalVariableDecl) VariableDeclarationList
										|    (NoMethodLocalVariableDecl) /*epsilon*/
										;

ReturnType ::= (FunctionReturnType) Type:returnType
			|  
				(NoReturnType) VOID
			;
			



/*Method Formal Parameters*/
OptionalMethodFormalParams ::= (MethodFormalParams) FormalParamDeclarationList
		 				 |
		 					(NoMethodFormalParams) /* epsilon */
		 				 ;
		  
FormalParamDeclarationList ::= (FormalParamDeclList) FormalParamDeclarationList COMMA FormalParamDeclaration
				|
							(OneFormalParamDecl) FormalParamDeclaration
				;
				
FormalParamDeclaration ::= (FormalParamDecl) Type:formalParamType IDENT:formalParamName OptionalSquareMethodFormalParam
						| 
							(ErrorFormalParamDecl) error:l
							{: parser.report_error("Izvrsen oporavak do ; ili , u liniji " + lleft, null);  :}
					;



OptionalSquareMethodFormalParam ::=  (ArrayFormalParam) LSQUARE RSQUARE
				|
									(NoArrayFormalParam)/*epsilon*/
				;				


		
/*Method Actual parameters*/ 
OptionalMethodActualParameters ::= (MethodActualParams) ActualParamDeclarationList
								| (NoMethodActualParams)/*epsilon*/
								;

ActualParamDeclarationList ::=  (ActualParamDeclList) ActualParamDeclarationList COMMA Expr
							|
								(OneActualParamDecl) Expr
							;
				



/*DESIGNATOR*/

Designator ::= (Designator) IDENT:variableName OptionalSpecifeIdentPartList
			;

OptionalSpecifeIdentPartList ::= (IdentParts) SpecifeIdentPartList
						|
								(NoIdentParts) /*epsilon*/
						;
					
SpecifeIdentPartList ::= (IdentPartList) SpecifeIdentPartList SpecifeIdentPart
					|
						(OneIdentPart) SpecifeIdentPart
					;


SpecifeIdentPart ::= (ClassMemberPart) DOT IDENT:classfieldName
					|
					 (ArrayMemberPart) LSQUARE Expr RSQUARE	
					;
				
DesignatorPart ::=  (AssignmentStmt) AssignmentStatement
				|	
				    (MetodCall) LPAREN OptionalMethodActualParameters RPAREN
				|	
				    (IncrementDesignator) INC
				|	
				    (DecrementDesignator) DEC
				;

				
DesignatorStatement ::= (DesignatorStmt) Designator DesignatorPart
					;

AssignmentStatement ::= (AssignmentExpr)  AssignmentOperator Expr
					|
					(AssignmentError) error:l
					{: parser.report_error("Izvrsen oporavak do ; ili , u liniji " + lleft, null);  :}
					;
			

/*OPERATORS*/

AddOperator ::= (PlusOp) PLUS
			|
				(MinusOp) MINUS
			;

MultiplyOperator ::= (MultiplyOp) MUL
				|
				(DivideOp) DIV
				|
				(ModuloOp) MOD
				;

RelationalOperator ::=  (EqualOp) EQUAL_COMPARE
					| 
						(NotEqualOp) NOT_EQUAL_COMPARE
					|
						(GreaterOp) GREATER
					|
						(GreaterEqualOp) GREATER_EQUAL
					|
						(LessOp) LESS
					|
						(LessEqualOp) LESS_EQUAL
					;

AssignmentOperator ::= (AssignOp) EQUAL
				;



/*Expression*/
Expr ::=    (TernarExpr) Expr1 TERNAR Expr1 COLON Expr1
		| 
			(NoTernarExpression) Expr1
		;
			
Expr1 ::= (BasicExpression) OptionalMinusVar TermList
	 	;
	 
OptionalMinusVar ::= (TermHaveMinus) MINUS
				 |
				  (TermDoNotHaveMinus) /*epsilon*/
	 			;
	 
TermList ::= (MultipleTerms) TermList AddOperator Term
		|
		 (OneTerm) Term
		;



/*TERM*/
Term ::= (TermDescription) FactorList;

FactorList ::= (MultipleFactors) FactorList MultiplyOperator Factor
		|
			 (OneFactor) Factor
		;



/*FACTOR*/
Factor ::= (NumConst) NUMBER
		| 
			(CharConst) CHAR
		| 
			(BoolConst) BOOLEAN
		| 
			(NewOperator) NEW Type  OptionalSquareNewOp
		| 
			(Var) Designator:d
		| 
			(FuncCall) Designator LPAREN OptionalMethodActualParameters RPAREN
		| 
			(ExprFactor) LPAREN Expr RPAREN
		;
		
OptionalSquareNewOp ::= (NewArrayVariable)  LSQUARE Expr RSQUARE
					| 
					 	(NewNonArrayVariable) /*epsilon*/
 					;


					 
/*CONDITION*/


Condition ::= (ConditionListOr) Condition OR ConditionTerm
			|
			  (OneConditionOr) ConditionTerm
			|
			  (ErrorCondition)/*epsilon*/
			;


ConditionTerm ::=  	(ConditionListAnd) ConditionTerm AND ConditionFact
				|
					(OneConditionAnd) ConditionFact
				;

ConditionFact ::= (TwoVariablesCondition)  Expr RelationalOperator Expr
				| 
				   (OneVariableCondition) Expr

				;
/*STATEMENT*/



Statement ::= (MatchedStmt) Matched
		   |
		   	  (UnmatchedStmt) Unmatched
		   ; 
		   
StatementList ::= (StmtList) StatementList Statement
		   |
		   		  (NoStmt) /*epsilon*/
		   ;

Unmatched ::=	(UnmatchedIf) IF LPAREN Condition RPAREN Statement
		 	|
		 		(UnmatchedIfElse) IF  LPAREN Condition RPAREN Matched ELSE Unmatched
		 	;


Matched ::= (MatchedDesignator) DesignatorStatement SEMI
		   |
		   (DoStmt) DO Statement WHILE LPAREN Condition RPAREN SEMI
		   |
		   (PrintStmt) PRINT LPAREN Expr OptionalPrintParam RPAREN SEMI
		   |
		   (ReadStmt) READ LPAREN Designator RPAREN SEMI
		   |
		   (ContinueStmt) CONTINUE SEMI
		   |
		   (BreakStmt) BREAK SEMI
		   |
		   (ReturnExpr) RETURN Expr SEMI
		   |
		   (ReturnNoExpr) RETURN SEMI
		   |
		   (MatchedStatement) IF LPAREN Condition RPAREN Matched ELSE Matched
		   |
		   (MultipleStatement) LBRACE StatementList RBRACE
		   |
		   (SwithStmt) SWITCH LPAREN Expr RPAREN LBRACE CaseStatementList RBRACE
		   ;

/*Print statement optional parameter */
OptionalPrintParam ::=  (AditionalParamPrint) COMMA NUMBER
					| 
						(NoAditionalParamPrint) /*epsilon*/
					; 


/*CASE STATEMENT*/
CaseStatementList ::= (CaseStmtList) CaseStatementList CaseStatement
				| (NoCaseStmt) /*epsilon*/
				;

CaseStatement ::= (CaseStmt) CASE NUMBER COLON StatementList
				;	





					